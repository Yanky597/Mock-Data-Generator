/* SAMPLE QUERIES that can be performed against the database*/


-- Retrieves all the employees who work under a particular manager
SELECT M.EMP_LNAME + ' ' + M.EMP_FNAME as MANAGER, 
	E.EMP_LNAME + ' ' + E.EMP_FNAME as EMPLOYEE
FROM EMPLOYEES as M 
JOIN EMPLOYEES as E 
on M.EMP_ID = E.EMP_MANAGER_ID
ORDER BY M.EMP_LNAME, M.EMP_FNAME DESC;		


--Get the Customer Ids, times the customer visited as well as the amount of time they spent on the website 
-- For the customers whos visits have a greater length than average
SELECT TOP 200 SESSIONS.CUS_ID, COUNT(SESSIONS.SES_ID) AS TIMES_VISTED, SUM(SESSIONS.SES_LENGTH) AS TIME_SPENT
FROM SESSIONS 
GROUP BY CUS_ID
HAVING AVG(SESSIONS.SES_LENGTH) > (SELECT AVG(SESSIONS.SES_LENGTH) FROM SESSIONS)
ORDER BY TIME_SPENT DESC


-- GET AMOUNT OF MONEY MADE FROM A PARTICULAR PROMO CODE
SELECT INVOICES.INV_REFCODE, COUNT(INVOICES.INV_ID) AS QTY, SUM(INVOICES.INV_TOTAL) AS SUM_TOTAL
FROM INVOICES
GROUP BY INVOICES.INV_REFCODE
ORDER BY SUM_TOTAL DESC


-- GET ALL SALES PEOPLE WITH THE AMOUNT OF SALES THAT THEY MADE, AND THEIR TOTAL SALES AMOUNTS
SELECT SALESPERSON.EMP_ID, COUNT(INVOICES.INV_ID) AS AMOUNT_SALES, SALESPERSON.SAL_TOTAL_SALES AS TOTAL_SALES
FROM SALESPERSON
LEFT OUTER JOIN INVOICES ON INVOICES.EMP_ID = SALESPERSON.EMP_ID
GROUP BY SALESPERSON.EMP_ID, SAL_TOTAL_SALES
ORDER BY AMOUNT_SALES DESC


-- GET THE EMPLOYEES WHO HAVE A BETTER THEN AVERAGE SALARY IN A GIVEN POSITION
SELECT EMP_LNAME, EMP_SALARY, POS_ID
FROM EMPLOYEES AS OUTERTABLE
WHERE EMP_SALARY >
                (SELECT AVG(EMP_SALARY)
                 FROM EMPLOYEES
                 WHERE EMPLOYEES.POS_ID =
                        OUTERTABLE.POS_ID);


-- GET THE DETAILS OF THE CUSTOMERS WHO HAVE MADE A PURCHASE
SELECT * FROM CUSTOMERS
WHERE CUS_ID IN(SELECT CUS_ID FROM CUSTOMERS
					INTERSECT
					SELECT CUS_ID FROM INVOICES)


-- GETS THE AMOUNT OF PEOPLE YOU HAVE WORKING IN A PARTICULAR POSITION
SELECT POSITIONS.POS_NAME, COUNT(EMPLOYEES.POS_ID) AS QTY
FROM EMPLOYEES
JOIN POSITIONS ON POSITIONS.POS_ID = EMPLOYEES.POS_ID
GROUP BY POS_NAME

-- GET THE BEST SELLING PRODUCT AND THE QUANTITY OF PRODUCTS THAT WERE SOLD
SELECT TOP 1 UPPER(PRODUCTS.PRO_NAME) AS NAME, SUM(INVOICE_ROW.INR_QUANTITY) AS TOTAL_QUANTITY
FROM INVOICE_ROW
JOIN PRODUCTS ON INVOICE_ROW.PRO_ID = PRODUCTS.PRO_ID
GROUP BY PRODUCTS.PRO_NAME
ORDER BY TOTAL_QUANTITY DESC

-- GETS THE DETAILS OF THE INVOICE WITH THE HIGHEST INVOICE TOTAL
SELECT CUSTOMERS.CUS_LNAME +', '+ CUSTOMERS.CUS_FNAME AS NAME, INVOICES.INV_ID, INVOICES.INV_TOTAL, INVOICE_ROW.INR_QUANTITY, UPPER(PRODUCTS.PRO_NAME) AS PRO_NAME
FROM INVOICES 
JOIN CUSTOMERS ON INVOICES.CUS_ID = CUSTOMERS.CUS_ID
JOIN INVOICE_ROW ON INVOICE_ROW.INV_ID = INVOICES.INV_ID
JOIN PRODUCTS ON PRODUCTS.PRO_ID = INVOICE_ROW.PRO_ID
WHERE INV_TOTAL = (SELECT MAX(INVOICES.INV_TOTAL) FROM INVOICES)

/*VIEWS*/


--CREATE VIEW
CREATE VIEW SALES_HISTORY AS
SELECT CUSTOMERS.CUS_FNAME + ', ' + CUSTOMERS.CUS_LNAME AS CUSTOMER_NAME, INVOICES.INV_ID, INVOICES.INV_DATE AS DATE, INVOICES.INV_TOTAL AS TOTAL
FROM CUSTOMERS
JOIN INVOICES
ON CUSTOMERS.CUS_ID = INVOICES.CUS_ID
--SAMPLE QUERY
SELECT * FROM [SALES_HISTORY]
WHERE TOTAL = (SELECT MAX(TOTAL) FROM [SALES_HISTORY])

--CREATE VIEW
-- GET A REPORT OF THE AMOUNT OF PROFITABILTY OF A GIVEN PRODUCT IN A YEAR
CREATE VIEW PRODUCT_REPORT AS 
SELECT TOP 1000
	UPPER(PRODUCTS.PRO_NAME) AS NAME,
	SUM(INVOICE_ROW.INR_QUANTITY) AS TOTAL_SOLD,
	SUM(INVOICE_ROW.INR_QUANTITY * (PRODUCTS.PRO_SALE_P - PRODUCTS.PRO_COST_P)) AS  TOTA_PROFIT, YEAR(INVOICES.INV_DATE) AS 'YEAR'
FROM PRODUCTS
	JOIN INVOICE_ROW ON INVOICE_ROW.PRO_ID = PRODUCTS.PRO_ID
	JOIN INVOICES ON INVOICE_ROW.INV_ID = INVOICES.INV_ID
GROUP BY PRODUCTS.PRO_NAME, YEAR(INVOICES.INV_DATE)
ORDER BY 'YEAR' ASC
--SAMPLE QUERY
-- GET THE MOST PROFITABLE ITEMS BY YEAR
SELECT PRODUCT_REPORT.NAME AS BST_SELLER, PRODUCT_REPORT.TOTA_PROFIT,  PRODUCT_REPORT.YEAR AS YEARS
FROM PRODUCT_REPORT
WHERE  PRODUCT_REPORT.TOTA_PROFIT IN ((SELECT MAX(PRODUCT_REPORT.TOTA_PROFIT) FROM PRODUCT_REPORT GROUP BY PRODUCT_REPORT.YEAR))


--CREATE VIEW
-- Retrieves (public) info about employees and protects more sensitive / personal information 
CREATE VIEW COMPANY_PERSONAL
AS
SELECT EMPLOYEES.EMP_LNAME, EMPLOYEES.EMP_FNAME, POSITIONS.POS_NAME
FROM EMPLOYEES INNER JOIN POSITIONS ON EMPLOYEES.POS_ID = POSITIONS.POS_ID
--SAMPLE QUERY
-- FIND EMPLOYEES WHO WORK IN HR
SELECT * FROM COMPANY_PERSONAL
WHERE POS_NAME = 'HR'


--CREATE VIEW
CREATE VIEW MANAGERS_SALARIES
AS
SELECT EMPLOYEES.EMP_ID, EMPLOYEES.EMP_LNAME, EMPLOYEES.EMP_FNAME AS MANAGERS, EMPLOYEES.EMP_SALARY, DEPARTMENTS.DEP_NAME
FROM EMPLOYEES JOIN MANAGERS
ON EMPLOYEES.EMP_ID = MANAGERS.EMP_ID
JOIN DEPARTMENTS
ON MANAGERS.DEP_ID = DEPARTMENTS.DEP_ID
--SAMPLE QUERY

-- GIVE THE SALES MANAGERS A RAISE AT THE END OF THE YEAR
UPDATE MANAGERS_SALARIES
SET EMP_SALARY += 10000
WHERE DEP_NAME = 'Sales'


/*TRIGGERS*/

-- The purpose of this trigger is to update the total amount of an invoice whenever an invoice row is inserted into the database.
CREATE TRIGGER UPDATE_INVOICE_TOTAL
ON INVOICE_ROW
AFTER INSERT
AS
UPDATE INVOICES
SET INVOICES.INV_TOTAL = OtherTable.sumTotal
FROM (
    SELECT INV_ID, SUM(INVOICE_ROW.INR_FINAL_PRICE) AS sumTotal 
    FROM INVOICE_ROW
	GROUP BY INV_ID) AS OtherTable
WHERE 
    INVOICES.INV_ID = OtherTable.INV_ID;

/*Stored Procedure*/

-- Description: A store procedure that returns all the invoices in a given range. 
CREATE PROCEDURE GET_INVOICES_IN_RANGE (@STARTDATE AS DATE, @ENDDATE AS DATE)

AS

BEGIN

    SELECT * FROM INVOICES
    WHERE INVOICES.INV_DATE BETWEEN @STARTDATE AND @ENDDATE
    ORDER BY INV_DATE

END




-- Description: A store procedure that returns all the products that were purchased by a particular customer.
CREATE PROCEDURE GET_PRODUCTS_PURCHASED @CUSTOMER_ID AS VARCHAR(45)
Ã¥
AS
DECLARE @ROWCOUNT AS NUMERIC
DECLARE @CUS_NAME AS VARCHAR(100)


BEGIN

SELECT @CUS_NAME = UPPER(CUSTOMERS.CUS_FNAME + ', ' + CUSTOMERS.CUS_LNAME)
FROM CUSTOMERS 
WHERE CUS_ID = @CUSTOMER_ID

SELECT @ROWCOUNT = COUNT(CUSTOMERS.CUS_FNAME)
	FROM  CUSTOMERS
		  JOIN INVOICES ON CUSTOMERS.CUS_ID = INVOICES.CUS_ID
		  JOIN INVOICE_ROW ON INVOICES.INV_ID = INVOICE_ROW.INV_ID
		  JOIN PRODUCTS ON INVOICE_ROW.PRO_ID = PRODUCTS.PRO_ID
    WHERE CUSTOMERS.CUS_ID = @CUSTOMER_ID

IF  @ROWCOUNT > 0
	BEGIN
	SELECT CUSTOMERS.CUS_ID, @CUS_NAME AS NAME, UPPER(PRODUCTS.PRO_NAME) AS PRO_NAME, SUM(INVOICE_ROW.INR_QUANTITY) AS QTY
	FROM  CUSTOMERS
		  JOIN INVOICES ON CUSTOMERS.CUS_ID = INVOICES.CUS_ID
		  JOIN INVOICE_ROW ON INVOICES.INV_ID = INVOICE_ROW.INV_ID
		  JOIN PRODUCTS ON INVOICE_ROW.PRO_ID = PRODUCTS.PRO_ID
	WHERE CUSTOMERS.CUS_ID = @CUSTOMER_ID
	GROUP BY CUSTOMERS.CUS_ID, PRODUCTS.PRO_NAME
	END
ELSE
PRINT @CUS_NAME + 'Has not yet made a purchase'

END


--Description: A stored procedure that returns products that are less profitable than AVG
CREATE PROCEDURE getUnderPerformingProducts @YEAR AS NUMERIC

AS

DECLARE @AVGPROFIT AS NUMERIC

BEGIN

    SELECT @AVGPROFIT = AVG(TOTA_PROFIT) FROM PRODUCT_REPORT

    SELECT * FROM PRODUCT_REPORT
    WHERE TOTA_PROFIT < @AVGPROFIT AND YEAR = @YEAR

END

--Description: A stored procedure for updating inventory quantities. Either in bulk, or one at a time.
CREATE PROCEDURE UPDATEINVENTORY @AMOUNT AS NUMERIC, @STATUSCODE AS VARCHAR(45)

AS

BEGIN
DECLARE @CURSOR AS CURSOR;
DECLARE @ID AS VARCHAR(45);
DECLARE @ROWCOUNT AS NUMERIC;
DECLARE @QUANTITY AS NUMERIC;
DECLARE @NAME AS VARCHAR(45);


IF @STATUSCODE = '0'
    BEGIN
        SET @CURSOR = CURSOR FOR SELECT INVENTORY.PRO_ID, INVENTORY.INV_QUANTITY, PRODUCTS.PRO_NAME FROM INVENTORY JOIN PRODUCTS ON INVENTORY.PRO_ID = PRODUCTS.PRO_ID;

        OPEN @CURSOR;
        FETCH NEXT FROM @CURSOR INTO @ID, @QUANTITY, @NAME;

        WHILE @@FETCH_STATUS = 0

        BEGIN
        UPDATE INVENTORY
        SET INV_QUANTITY += @AMOUNT
        WHERE INVENTORY.PRO_ID = @ID
        PRINT STR(@ID) + ' ' + @NAME + ' ' + STR(@QUANTITY) + ' : HAS BEEN UPDATED ';
        FETCH NEXT FROM @CURSOR INTO @ID, @QUANTITY, @NAME;
    END
END

ELSE
    SELECT @ROWCOUNT = COUNT(INVENTORY.PRO_ID) FROM INVENTORY WHERE PRO_ID = @STATUSCODE;

    IF @ROWCOUNT > 0
        BEGIN

        SELECT @QUANTITY = INVENTORY.INV_QUANTITY FROM INVENTORY WHERE PRO_ID = @STATUSCODE
        SELECT @NAME = PRODUCTS.PRO_NAME FROM PRODUCTS WHERE PRO_ID = @STATUSCODE

        UPDATE INVENTORY
        SET INVENTORY.INV_QUANTITY += @AMOUNT
        WHERE INVENTORY.PRO_ID = @STATUSCODE
        PRINT @STATUSCODE + ' ' + @NAME + ' ' + STR(@QUANTITY) + ' :    HAS BEEN UPDATED';
        END

    ELSE
        PRINT '***PRODUCT ID WAS NOT FOUND***';

END



--Description: A stored procedure for getting the information of all customers who live in a particular zip code.

CREATE PROCEDURE getCustomersByZip @zipCode AS VARCHAR(45)

AS

    BEGIN 

        SELECT * FROM CUSTOMERS 
        WHERE CUSTOMERS.CUS_ZIPCODE = @zipCode;

    END


/*User Defined Function*/

--Description: A user defined function that returns the inventory quantity of a particular product. Useful for comparing inventory stock on multiple products.
ALTER FUNCTION getInStockQTY 
(
	@PRO_ID AS VARCHAR(45)
)
RETURNS INT

AS

BEGIN
	DECLARE @QUANTITY AS INT;
	SET  @QUANTITY =(SELECT INVENTORY.INV_QUANTITY FROM INVENTORY WHERE INVENTORY.PRO_ID = @PRO_ID);
	RETURN @QUANTITY;
END


--Description: A user defined function that returns a comprehensive view of any employee that also includes his department and position.
CREATE FUNCTION getEmployeeInfo 
(
	@EMP_ID AS VARCHAR(45)
)
RETURNS TABLE

AS

RETURN
	(
		SELECT EMPLOYEES.EMP_ID AS ID, 
		EMPLOYEES.EMP_LNAME AS LNAME, 
		EMPLOYEES.EMP_FNAME AS FNAME, 
		EMPLOYEES.EMP_PHONE AS PHONE, 
		EMPLOYEES.EMP_EMAIL AS EMAIL, 
		EMPLOYEES.EMP_SALARY AS SALARY, 
		EMPLOYEES.EMP_DURATION AS STARTDATE, 
		EMPLOYEES.EMP_MANAGER_ID AS MANGER, 
		POSITIONS.POS_NAME AS POSITION, 
		DEPARTMENTS.DEP_NAME AS DEPARTMENT
		FROM EMPLOYEES
		JOIN POSITIONS ON EMPLOYEES.POS_ID = POSITIONS.POS_ID
		JOIN DEPARTMENTS ON POSITIONS.DEP_ID = DEPARTMENTS.DEP_ID
		WHERE EMPLOYEES.EMP_ID = @EMP_ID
		
	)
GO
